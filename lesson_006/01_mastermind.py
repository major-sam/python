# -*- coding: utf-8 -*-
from termcolor import cprint, colored
from lesson_006.mastermind_engine import make_secret_num, secret_num, game_mech

# Игра «Быки и коровы»
# https://goo.gl/Go2mb9
#
# Правила:
# Компьютер загадывает четырехзначное число, все цифры которого различны
# (первая цифра числа отлична от нуля). Игроку необходимо разгадать задуманное число.
# Игрок вводит четырехзначное число c неповторяющимися цифрами,
# компьютер сообщают о количестве «быков» и «коров» в названном числе
# «бык» — цифра есть в записи задуманного числа и стоит в той же позиции,
#       что и в задуманном числе
# «корова» — цифра есть в записи задуманного числа, но не стоит в той же позиции,
#       что и в задуманном числе
#
# Например, если задумано число 3275 и названо число 1234,
# получаем в названном числе одного «быка» и одну «корову».
# Очевидно, что число отгадано в том случае, если имеем 4 «быка».
#
# Формат ответа компьютера
# > быки - 1, коровы - 1
# try_counter = 0
res = {}
_try_counter = 1


def user_try():
    global _try_counter
    while True:
        try_num = input(colored('Введите 4х значное число\n', 'green'))
        try_list = list(map(int, list(try_num)))
        _try_counter += 1
        err_counter = 0
        for n in try_list:
            if try_list.count(n) > 1:
                err_counter += 1
        if len(try_num) != 4:
            cprint('Число должно состоять из четырех цифр', 'red')
            continue
        elif not try_num.isdigit():
            cprint('Введены неверные символы', 'red')
            continue
        elif err_counter != 0:
            cprint('В числе не должно быть одинаковых цифр', 'red', attrs=['reverse'])
            continue
        else:
            break
    return try_list


def end_game():
    return res['bulls'] == 4


make_secret_num()
while True:
    sep = ''
    num = user_try()
    res = game_mech(num)
    bulls, cows = res['bulls'], res['cows']
    cprint('Попытка № {0}\n\t{1}'.format(_try_counter, sep.join(map(str, num))), 'green')
    cprint('Быков: {}'.format(bulls), 'blue')
    cprint('Коров: {}'.format(cows), 'blue')
    if end_game():
        cprint('Загаданное число: {}'.format(sep.join(secret_num)), 'blue', attrs=['reverse'])
        new_pick = input("Хотите еще партию? y/n\n")
        if new_pick in ['Y', 'y', 'Yes', 'yes']:
            make_secret_num()
        else:
            break

# Составить отдельный модуль mastermind_engine, реализующий функциональность игры.
# В этом модуле нужно реализовать функции:
#   загадать_число()
#   проверить_число(NN) - возвращает словарь {'bulls': N, 'cows': N}
# Загаданное число хранить в глобальной переменной.
# Обратите внимание, что строки - это список символов.
#
# В текущем модуле (lesson_006/01_mastermind.py) реализовать логику работы с пользователем:
#   модуль движка загадывает число
#   в цикле, пока число не отгадано
#       у пользователя запрашивается вариант числа
#       модуль движка проверяет число и выдает быков/коров
#       результат быков/коров выводится на консоль
#  когда игрок угадал таки число - показать количество ходов и вопрос "Хотите еще партию?"
#
# При написании кода учитывайте, что движок игры никак не должен взаимодействовать с пользователем.
# Все общение с пользователем делать в текущем модуле. Представьте, что движок игры могут использовать
# разные клиенты - веб, чатбот, приложение, етс - они знают как спрашивать и отвечать пользователю.
# Движок игры реализует только саму функциональность игры.
# Это пример применения SOLID принципа (см https://goo.gl/GFMoaI) в архитектуре программ.
# Точнее, в этом случае важен принцип единственной ответственности - https://goo.gl/rYb3hT
